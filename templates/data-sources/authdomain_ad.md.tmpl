---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "{{ .Name }} {{ .Type }} - {{ .ProviderName }}"
subcategory: ""
description: |-
  {{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{ .Name }} ({{ .Type | title }})

Provides information about an Active Directory authentication domain.

## Example Usage

```terraform
# Get information about a specific AD authentication domain
data "wallix-bastion_authdomain_ad" "corporate" {
  domain_name = "corporate.local"
}

# Use AD domain information in authentication configuration
resource "wallix-bastion_user" "ad_user" {
  user_name      = "john.doe"
  auth_domain    = data.wallix-bastion_authdomain_ad.corporate.domain_name
  user_source    = "active_directory"
}

# Get multiple AD domains for comparison
data "wallix-bastion_authdomain_ad" "primary" {
  domain_name = "primary.company.com"
}

data "wallix-bastion_authdomain_ad" "secondary" {
  domain_name = "secondary.company.com"
}

data "wallix-bastion_authdomain_ad" "partner" {
  domain_name = "partner.company.com"
}

# Compare AD domain configurations
locals {
  ad_domains = {
    primary   = data.wallix-bastion_authdomain_ad.primary
    secondary = data.wallix-bastion_authdomain_ad.secondary
    partner   = data.wallix-bastion_authdomain_ad.partner
  }
  
  # Find domains with SSL enabled
  secure_domains = {
    for name, domain in local.ad_domains :
    name => domain if domain.use_ssl
  }
  
  # Find domains with group checking enabled
  group_validated_domains = {
    for name, domain in local.ad_domains :
    name => domain if domain.check_user_group
  }
}

# Validate AD domain configuration
locals {
  domain_validation = {
    has_ldap_hosts = length(data.wallix-bastion_authdomain_ad.corporate.ldap_hosts) > 0
    uses_secure_port = data.wallix-bastion_authdomain_ad.corporate.ldap_port == 636
    ssl_enabled = data.wallix-bastion_authdomain_ad.corporate.use_ssl
    cert_verified = data.wallix-bastion_authdomain_ad.corporate.verify_certificate
    has_service_account = length(data.wallix-bastion_authdomain_ad.corporate.ldap_login) > 0
    has_base_dn = length(data.wallix-bastion_authdomain_ad.corporate.ldap_base) > 0
  }
  
  configuration_score = length([for k, v in local.domain_validation : k if v])
}

# Create authentication mapping based on AD domain info
resource "wallix-bastion_authdomain_mapping" "ad_mapping" {
  domain_name     = data.wallix-bastion_authdomain_ad.corporate.domain_name
  auth_domain     = data.wallix-bastion_authdomain_ad.corporate.domain_name
  user_group      = data.wallix-bastion_authdomain_ad.corporate.user_group
  group_filter    = data.wallix-bastion_authdomain_ad.corporate.group_source_filter
}

# Monitor AD domain connectivity
output "ad_domain_health" {
  description = "Health status of AD authentication domains"
  value = {
    corporate = {
      domain_name = data.wallix-bastion_authdomain_ad.corporate.domain_name
      ldap_hosts  = data.wallix-bastion_authdomain_ad.corporate.ldap_hosts
      ldap_port   = data.wallix-bastion_authdomain_ad.corporate.ldap_port
      ssl_enabled = data.wallix-bastion_authdomain_ad.corporate.use_ssl
      is_default  = data.wallix-bastion_authdomain_ad.corporate.is_default
      language    = data.wallix-bastion_authdomain_ad.corporate.default_language
    }
  }
}

# Security assessment of AD domains
locals {
  security_assessment = {
    for name, domain in local.ad_domains :
    name => {
      ssl_encryption = domain.use_ssl
      certificate_validation = domain.verify_certificate
      secure_port = domain.ldap_port == 636
      group_validation = domain.check_user_group
      has_backup_servers = length(domain.ldap_hosts) > 1
      
      # Calculate security score
      security_score = (
        (domain.use_ssl ? 30 : 0) +
        (domain.verify_certificate ? 20 : 0) +
        (domain.ldap_port == 636 ? 20 : 0) +
        (domain.check_user_group ? 15 : 0) +
        (length(domain.ldap_hosts) > 1 ? 15 : 0)
      )
    }
  }
}

output "security_assessment" {
  description = "Security assessment of AD authentication domains"
  value       = local.security_assessment
}

# Generate AD domain documentation
locals {
  ad_documentation = {
    for name, domain in local.ad_domains :
    name => {
      connection = {
        hosts     = domain.ldap_hosts
        port      = domain.ldap_port
        base_dn   = domain.ldap_base
        use_ssl   = domain.use_ssl
        verify_cert = domain.verify_certificate
      }
      
      authentication = {
        service_account = domain.ldap_login
        default_domain  = domain.default_domain
        is_default     = domain.is_default
        language       = domain.default_language
      }
      
      user_mapping = {
        user_cn    = domain.user_cn
        user_dn    = domain.user_dn
        user_email = domain.user_email
        user_group = domain.user_group
        user_source = domain.user_source
        user_filter = domain.user_source_filter
      }
      
      group_settings = {
        check_groups = domain.check_user_group
        group_filter = domain.group_source_filter
      }
      
      external_refs = domain.external_ldaps
    }
  }
}

# Export configuration for backup/documentation
output "ad_domain_configurations" {
  description = "Complete AD domain configurations for documentation"
  value       = local.ad_documentation
  sensitive   = false
}

# Compliance checking for AD domains
locals {
  compliance_check = {
    for name, domain in local.ad_domains :
    name => {
      # Security compliance
      encryption_required = domain.use_ssl
      certificate_validation = domain.verify_certificate
      
      # Operational compliance
      multiple_servers = length(domain.ldap_hosts) > 1
      service_account_configured = length(domain.ldap_login) > 0
      base_dn_configured = length(domain.ldap_base) > 0
      
      # User management compliance
      user_attributes_mapped = (
        length(domain.user_cn) > 0 &&
        length(domain.user_email) > 0 &&
        length(domain.user_group) > 0
      )
      
      # Group validation enabled
      group_validation = domain.check_user_group
      
      # Overall compliance score
      compliance_score = (
        (domain.use_ssl ? 1 : 0) +
        (domain.verify_certificate ? 1 : 0) +
        (length(domain.ldap_hosts) > 1 ? 1 : 0) +
        (length(domain.ldap_login) > 0 ? 1 : 0) +
        (domain.check_user_group ? 1 : 0)
      )
    }
  }
}

output "compliance_report" {
  description = "Compliance report for AD authentication domains"
  value = {
    for name, check in local.compliance_check :
    name => {
      score = "${check.compliance_score}/5"
      details = check
      status = check.compliance_score >= 4 ? "compliant" : "needs_improvement"
    }
  }
}

# Create high availability configuration insight
locals {
  ha_analysis = {
    for name, domain in local.ad_domains :
    name => {
      server_count = length(domain.ldap_hosts)
      has_redundancy = length(domain.ldap_hosts) > 1
      external_ldaps = length(domain.external_ldaps)
      
      # HA recommendations
      recommendations = concat(
        length(domain.ldap_hosts) <= 1 ? ["Add secondary LDAP servers for redundancy"] : [],
        !domain.use_ssl ? ["Enable SSL/TLS encryption"] : [],
        !domain.verify_certificate ? ["Enable certificate verification"] : [],
        !domain.check_user_group ? ["Enable group membership validation"] : []
      )
    }
  }
}

output "high_availability_analysis" {
  description = "High availability analysis for AD domains"
  value       = local.ha_analysis
}

# Integration testing helpers
locals {
  integration_tests = {
    for name, domain in local.ad_domains :
    name => {
      connection_test = {
        primary_server = length(domain.ldap_hosts) > 0 ? domain.ldap_hosts[0] : null
        port = domain.ldap_port
        ssl = domain.use_ssl
        command = domain.use_ssl ? 
          "openssl s_client -connect ${domain.ldap_hosts[0]}:${domain.ldap_port}" :
          "nc -zv ${domain.ldap_hosts[0]} ${domain.ldap_port}"
      }
      
      ldap_test = {
        base_dn = domain.ldap_base
        service_account = domain.ldap_login
        test_search = "ldapsearch -x -H ldap${domain.use_ssl ? "s" : ""}://${domain.ldap_hosts[0]}:${domain.ldap_port} -D '${domain.ldap_login}' -b '${domain.ldap_base}' '(objectClass=user)'"
      }
    }
  }
}

output "integration_test_commands" {
  description = "Commands for testing AD domain connectivity"
  value       = local.integration_tests
}
```

{{ .SchemaMarkdown | trimspace }}

## Usage Notes

### Active Directory Domain Attributes

**Connection Configuration:**
- `domain_name`: The AD domain name
- `ldap_hosts`: List of domain controllers/LDAP servers
- `ldap_port`: LDAP port (389 for LDAP, 636 for LDAPS)
- `ldap_base`: Base DN for LDAP searches
- `ldap_login`: Service account DN for authentication
- `use_ssl`: Whether SSL/TLS encryption is enabled
- `verify_certificate`: Whether to verify server certificates

**Domain Settings:**
- `default_domain`: Default domain identifier
- `is_default`: Whether this is the default authentication domain
- `default_language`: Default language for domain users

**User Attribute Mapping:**
- `user_cn`: Common name attribute (typically "sAMAccountName")
- `user_dn`: Distinguished name attribute
- `user_email`: Email attribute (typically "mail")
- `user_group`: Group membership attribute (typically "memberOf")
- `user_source`: User source attribute
- `user_source_filter`: LDAP filter for user searches

**Group Configuration:**
- `check_user_group`: Whether group membership validation is enabled
- `group_source_filter`: LDAP filter for group searches

**External References:**
- `external_ldaps`: List of external LDAP server references

### Domain Analysis

**Security Assessment:**
```terraform
locals {
  security_features = {
    encryption = data.wallix-bastion_authdomain_ad.domain.use_ssl
    cert_validation = data.wallix-bastion_authdomain_ad.domain.verify_certificate
    secure_port = data.wallix-bastion_authdomain_ad.domain.ldap_port == 636
    group_validation = data.wallix-bastion_authdomain_ad.domain.check_user_group
  }
}
```

**Configuration Validation:**
```terraform
locals {
  config_validation = {
    has_servers = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts) > 0
    has_service_account = length(data.wallix-bastion_authdomain_ad.domain.ldap_login) > 0
    has_base_dn = length(data.wallix-bastion_authdomain_ad.domain.ldap_base) > 0
    proper_port = contains([389, 636], data.wallix-bastion_authdomain_ad.domain.ldap_port)
  }
}
```

### High Availability Analysis

**Redundancy Check:**
```terraform
locals {
  ha_status = {
    server_count = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts)
    has_redundancy = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts) > 1
    external_refs = length(data.wallix-bastion_authdomain_ad.domain.external_ldaps)
  }
}
```

### Integration with Resources

**User Creation:**
```terraform
resource "wallix-bastion_user" "ad_users" {
  for_each = toset(["user1", "user2", "user3"])
  
  user_name   = each.key
  auth_domain = data.wallix-bastion_authdomain_ad.corporate.domain_name
  user_source = "active_directory"
}
```

**Domain Mapping:**
```terraform
resource "wallix-bastion_authdomain_mapping" "ad_mapping" {
  domain_name  = data.wallix-bastion_authdomain_ad.corporate.domain_name
  auth_domain  = data.wallix-bastion_authdomain_ad.corporate.domain_name
  user_group   = data.wallix-bastion_authdomain_ad.corporate.user_group
  group_filter = data.wallix-bastion_authdomain_ad.corporate.group_source_filter
}
```

### Monitoring and Health Checks

**Domain Health Monitoring:**
```terraform
output "ad_domain_status" {
  value = {
    connection = {
      servers = data.wallix-bastion_authdomain_ad.domain.ldap_hosts
      port = data.wallix-bastion_authdomain_ad.domain.ldap_port
      ssl = data.wallix-bastion_authdomain_ad.domain.use_ssl
    }
    configuration = {
      base_dn = data.wallix-bastion_authdomain_ad.domain.ldap_base
      service_account = data.wallix-bastion_authdomain_ad.domain.ldap_login
      group_validation = data.wallix-bastion_authdomain_ad.domain.check_user_group
    }
  }
}
```

### Compliance and Security

**Security Compliance:**
```terraform
locals {
  security_compliance = {
    encryption_enabled = data.wallix-bastion_authdomain_ad.domain.use_ssl
    certificate_verified = data.wallix-bastion_authdomain_ad.domain.verify_certificate
    secure_port_used = data.wallix-bastion_authdomain_ad.domain.ldap_port == 636
    group_checking = data.wallix-bastion_authdomain_ad.domain.check_user_group
    redundancy = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts) > 1
  }
  
  compliance_score = length([for k, v in local.security_compliance : k if v])
}
```

### Configuration Backup

**Export Configuration:**
```terraform
output "ad_domain_backup" {
  description = "AD domain configuration for backup purposes"
  value = {
    domain_name = data.wallix-bastion_authdomain_ad.domain.domain_name
    connection = {
      hosts = data.wallix-bastion_authdomain_ad.domain.ldap_hosts
      port = data.wallix-bastion_authdomain_ad.domain.ldap_port
      base = data.wallix-bastion_authdomain_ad.domain.ldap_base
      ssl = data.wallix-bastion_authdomain_ad.domain.use_ssl
    }
    mapping = {
      user_cn = data.wallix-bastion_authdomain_ad.domain.user_cn
      user_email = data.wallix-bastion_authdomain_ad.domain.user_email
      user_group = data.wallix-bastion_authdomain_ad.domain.user_group
    }
  }
  sensitive = false
}
```

### Troubleshooting Information

**Diagnostic Data:**
```terraform
output "ad_domain_diagnostics" {
  description = "Diagnostic information for AD domain troubleshooting"
  value = {
    connection_info = {
      primary_server = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts) > 0 ? 
                      data.wallix-bastion_authdomain_ad.domain.ldap_hosts[0] : null
      port = data.wallix-bastion_authdomain_ad.domain.ldap_port
      ssl = data.wallix-bastion_authdomain_ad.domain.use_ssl
      protocol = data.wallix-bastion_authdomain_ad.domain.use_ssl ? "ldaps" : "ldap"
    }
    
    test_commands = {
      connectivity = "nc -zv ${data.wallix-bastion_authdomain_ad.domain.ldap_hosts[0]} ${data.wallix-bastion_authdomain_ad.domain.ldap_port}"
      ldap_test = "ldapsearch -x -H ${data.wallix-bastion_authdomain_ad.domain.use_ssl ? "ldaps" : "ldap"}://${data.wallix-bastion_authdomain_ad.domain.ldap_hosts[0]}:${data.wallix-bastion_authdomain_ad.domain.ldap_port} -b '${data.wallix-bastion_authdomain_ad.domain.ldap_base}' '(objectClass=user)'"
    }
  }
}
```

### Best Practices Validation

**Configuration Best Practices:**
```terraform
locals {
  best_practices = {
    ssl_encryption = data.wallix-bastion_authdomain_ad.domain.use_ssl
    certificate_validation = data.wallix-bastion_authdomain_ad.domain.verify_certificate
    multiple_servers = length(data.wallix-bastion_authdomain_ad.domain.ldap_hosts) > 1
    group_validation = data.wallix-bastion_authdomain_ad.domain.check_user_group
    proper_user_mapping = (
      length(data.wallix-bastion_authdomain_ad.domain.user_cn) > 0 &&
      length(data.wallix-bastion_authdomain_ad.domain.user_email) > 0 &&
      length(data.wallix-bastion_authdomain_ad.domain.user_group) > 0
    )
  }
  
  recommendations = [
    for practice, enabled in local.best_practices :
    "Enable ${replace(practice, "_", " ")}" if !enabled
  ]
}
```

## Import

AD authentication domains are read-only data sources and cannot be imported.

## Read-Only Attributes

All attributes of the AD authentication domain are read-only:

- **domain_name**: The Active Directory domain name
- **default_domain**: Default domain identifier
- **description**: Domain description
- **default_language**: Default language setting
- **ldap_hosts**: List of LDAP/domain controller hosts
- **ldap_port**: LDAP connection port
- **ldap_base**: LDAP base DN for searches
- **ldap_login**: Service account login DN
- **use_ssl**: SSL/TLS encryption status
- **verify_certificate**: Certificate verification status
- **is_default**: Default domain status
- **user_cn**: User common name attribute mapping
- **user_dn**: User distinguished name attribute mapping
- **user_email**: User email attribute mapping
- **user_group**: User group membership attribute mapping
- **user_source**: User source attribute
- **user_source_filter**: LDAP filter for user searches
- **check_user_group**: Group membership validation status
- **group_source_filter**: LDAP filter for group searches
- **external_ldaps**: List of external LDAP references